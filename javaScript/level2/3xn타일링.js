// 짝수인 경우만 경우의 수가 존재하므로 홀수는 배제한다
// 따라서 n=0일땐 index[0], n=2일떈 index[1] ... 로 접근한다
const dp = [0, 3, 11];
// 위 주석에서 설명하듯이 index는 n을 2로 나눈 값이다.
const idx = n >> 1;

// n이 짝수가 아니라면 바로 0을 리턴한다.
// 따라서 우리는 dp 배열에 홀수인 경우를 고려하지 않아도 된다.
if(n % 2) return 0;
// 인덱스가 3보다 작은 경우, 즉 0, 1, 2인 경우에는
// 이미 dp 배열에 그 값이 초기화 되어있으므로 바로 리턴
// 사실 생략해도 문제는 없다.
if(idx < 3) return dp[idx];
// 문제 제한조건에 의한 MOD 값 선언
const MOD = 1000000007;

// idx=3 부터는 dp 배열에 값이 들어있지 않으므로
// 이 값부터 반복문을 돌려주자.
// 범위는 위에서 구한 idx까지 돌리면 된다.
for(let i = 3; i <= idx; i++) {
  // 여기서 3은 dp[1], 즉 n=2 일때의 값과 같다.
  // dp[1]로 선언해도 상관없다.
  // 2는 n=x 일때, x에서 구성할 수 있는 새로운 패턴 2가지이다.
  dp[i] = dp[i-1] * 3 + 2;
  
  // dp[j]는 n=x 일때, (x-2) ~ (2) 까지의 범위이다.
  // 위에서의 첫 연산을 제외하면 각각 이전에 구한 조합은
  // 모두 새로운 패턴인 2가지와 곱해지는 것을 위에서 살펴보았다.
  // i일때 연산은 위에서 2를 더해줌으로 미리 수행했기에
  // i-1 범위까지 반복해주도록 하자.
  for(let j = 1; j < i-1; j++) {
    dp[i] += dp[j] * 2;
  }
  
  // 연산 후에 꼭 MOD 값을 적용해서 저장해주자!
  dp[i] %= MOD;
}

return dp[idx];